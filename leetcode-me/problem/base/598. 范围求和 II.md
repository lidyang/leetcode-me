## 题目地址
https://leetcode-cn.com/problems/range-addition-ii/

## 题目描述

给定一个初始元素全部为 0，大小为 m*n 的矩阵 M 以及在 M 上的一系列更新操作。

操作用二维数组表示，其中的每个操作用一个含有两个正整数 a 和 b 的数组表示，含义是将所有符合 0 <= i < a 以及 0 <= j < b 的元素 M[i][j] 的值都增加 1。

在执行给定的一系列操作后，你需要返回矩阵中含有最大整数的元素个数。


### 示例 1:

    输入: 
    m = 3, n = 3
    operations = [[2,2],[3,3]]
    输出: 4
    解释: 
    初始状态, M = 
    [[0, 0, 0],
     [0, 0, 0],
     [0, 0, 0]]
    
    执行完操作 [2,2] 后, M = 
    [[1, 1, 0],
     [1, 1, 0],
     [0, 0, 0]]
    
    执行完操作 [3,3] 后, M = 
    [[2, 2, 1],
     [2, 2, 1],
     [1, 1, 1]]
    
    M 中最大的整数是 2, 而且 M 中有4个值为2的元素。因此返回 4

### 注意:

    m 和 n 的范围是[1,40000]
    a 的范围是 [1,m]，b 的范围是 [1,n]
    操作数目不超过 10000





## 解题思路

方法一：所有操作的交集

    由于a和b都是正整数，位置[0,0]的元素是所有操作都会执行的元素，也是操作后最大值，要找到最大元素的个数，在横向和纵向上找到所有操作共同操作的元素，即最小值，横纵方向最小值范围内的元素数即为答案。
    
    
 Java代码

    public int maxCount(int m, int n, int[][] ops) {
                int ans = 0;
                int m_min = m;
                int n_min = n;
                for (int []op : ops){
                    if ( op[0] < m_min){
                        m_min = op[0];
                    }
                    if ( op[1] < n_min){
                        n_min = op[1];
                    }
                }
                return m_min*n_min;
            }
        
 
 
 **复杂度分析**
 
 时间复杂度：O(k)，其中 k 是数组 ops 的长度。
 
 空间复杂度：O(1)。


