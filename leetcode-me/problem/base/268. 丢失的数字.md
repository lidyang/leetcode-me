## 题目地址
https://leetcode-cn.com/problems/missing-number/

## 题目描述

给定一个包含 [0, n] 中 n 个数的数组 nums ，找出 [0, n] 这个范围内没有出现在数组中的那个数。



示例 1：

    输入：nums = [3,0,1]
    输出：2
    解释：n = 3，因为有 3 个数字，所以所有的数字都在范围 [0,3] 内。2 是丢失的数字，因为它没有出现在 nums 中。

示例 2：

    输入：nums = [0,1]
    输出：2
    解释：n = 2，因为有 2 个数字，所以所有的数字都在范围 [0,2] 内。2 是丢失的数字，因为它没有出现在 nums 中。

示例 3：

    输入：nums = [9,6,4,2,3,5,7,0,1]
    输出：8
    解释：n = 9，因为有 9 个数字，所以所有的数字都在范围 [0,9] 内。8 是丢失的数字，因为它没有出现在 nums 中。

示例 4：

    输入：nums = [0]
    输出：1
    解释：n = 1，因为有 1 个数字，所以所有的数字都在范围 [0,1] 内。1 是丢失的数字，因为它没有出现在 nums 中。



提示：

    2 <= nums.length <= 104
    -109 <= nums[i] <= 109
    -109 <= target <= 109
    只会存在一个有效答案
进阶：你可以想出一个时间复杂度小于 O(n2) 的算法吗？



## 解题思路

方法一：排序

    首先对数组进行排序，然后循环对比，找不到数字和下标不一致的数字，即为缺失的数字。
    
   Java代码
   
    ```        public int missingNumber(int[] nums) {
            Arrays.sort(nums);
            for(int i=0;i<nums.length;i++){
                if (i != nums[i] )
                    return i;
            }
            return nums.length;
            
        }
        
    ```
 
 **复杂度分析**
 
 时间复杂度：O(nlogn)，其中 n是数组 nums 的长度。排序的时间复杂度是O(nlogn)，遍历数组寻找丢失的数字的时间复杂度是O(n)，因此总时间复杂度是O(nlogn)。
 
 空间复杂度：O(logn)，其中 n 是数组 nums 的长度。空间复杂度主要取决于排序的递归调用栈空间。
 



方法二：哈希集合

    把数组所有元素放入一个哈希列表中，在判断1-n所有数字是否在哈希列表，就可以找出丢失的数字

  Java代码
  
  ```
    public int missingNumber(int[] nums) {

        Set set = new HashSet<Integer>();
        for(int i:nums){
            set.add(i);
        }
        for(int i=0;i<=nums.length;i++){
            if(!set.contains(i)){
                return  i;
            }
        }
        return -1;
    }

```
               
 **复杂度分析**
 
 时间复杂度：O(n)，其中 n是数组 nums 的长度。遍历数组nums将元素加入哈希集合的时间复杂度是 O(n)，遍历从 0 到 n的每个整数并判断是否在哈希集合中的时间复杂度也是 O(n)
                             
                             
 空间复杂度：O(logn)，其中 n 是数组 nums 的长度。哈希集合中需要存储 n 个整数
     


方法三：位运算

    对数组元素和0-n的所有数字做位异或运算，除了丢失的数字出现1次意外，其他数字都会出现2次，异或运算后为0，对所有数字异或运算后的结果即为所要找的数字。
    
   Java代码
   
   ```
     public int missingNumber(int[] nums) {
                int ans = 0;       
                for(int i:nums){
                    ans = ans ^ i;
                }
                for(int i=0;i<=nums.length;i++){
                    ans = ans^i;
                }       
                return ans;
            }

```

               
 **复杂度分析**
 
 时间复杂度：O(n)                 
                             
 空间复杂度：O(1)


方法四：数学公式

    首先计算0-n所有数字的和，然后再减去nums数组中所有的数字，最后的结果就是丢失的数字
   
   Java代码
   
   ```
      public int missingNumber(int[] nums) {
            int length  = nums.length;
            int sum = length*(length+1)/2;
            for(int i:nums){
                sum = sum -i;
            }
            return sum;
        }

   ```
               
 **复杂度分析**
 
 时间复杂度：O(n)                 
                             
 空间复杂度：O(1)

